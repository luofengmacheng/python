## 用asyncio协程实现的网络爬虫

> http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html

### 1 简介

传统的计算机科学都将重点放在如何用高效的算法优化性能，但是网络应用程序通常会面临不同的挑战：

* 会保持大量慢速的连接
* 事件不频繁

网络爬虫也是这样：网络爬虫需要并发地发起大量请求，并等待响应，计算工作却很少。因此，大量的资源都消耗在保持连接上，大量的时间都消耗在网络IO上。

如果用多线程进行优化，每个线程发起请求并处理响应，但是每个连接也会占用操作系统资源，在面对大量连接的情况下，还没用完句柄时，就会耗尽内存和线程占用的资源。因此，这里使用异步IO进行优化。

下面会以三个阶段解决这个问题：

* 使用事件循环和回调：非常高效，但是难以扩展和维护
* 使用python生成器实现的协程：高效并可扩展
* 使用python的异步标准库asyncio和异步队列

### 2 任务

网络爬虫的工作方式：

* 给定一个根URL，并将根路径放入到一个待爬取队列A和获取的URL的set B
* 循环从待爬取队列A中获取一个URL，爬取该URL，解析页面的链接，如果解析到的链接不在B中，将链接也放入待爬取队列A和集合B
* 当待爬取队列中为空时结束循环

### 3 传统方法

最常见的优化方式就是使用多线程/多进程，当获取一个URL，就启动一个线程/进程爬取页面并解析，但是如果链接较多，线程/进程频繁地创建和销毁，消耗了大量资源，而且在线程/进程生存期间，它的主要耗时是在等待服务器的返回。进一步，可以使用线程池/进程池优化线程和进程的创建和销毁。

但是，用多线程时，每个线程需要系统资源(例如内存)，当线程个数达到一定数量时，系统就会崩溃，因此，系统对于线程的限制就成为了瓶颈。

另外，在每个线程中，connect()和recv()是很耗时的操作，并且默认情况下，它们是阻塞的，也就是执行结束，函数才会返回。

### 4 异步

异步IO框架的一个特点是需要使用非阻塞的函数，例如connect()：

``` python
sock = socket.socket()
sock.setblocking(False)
try:
    sock.connect(('xkcd.com', 80))
except BlockingIOError:
    pass
```

上面的代码将套接字设置为非阻塞，然后就会以非阻塞方式执行connect()函数，当连接没有建立结束时，就会抛出BlockingIOError异常，抛出该异常只是说操作还没有完成。上面的程序在处理完连接的异常后，程序就会往下执行，那么连接操作何时执行结束呢？只有当连接操作执行结束我们才能进行正常的收发数据。