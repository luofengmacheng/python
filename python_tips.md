## python中的高级特性

### 1 GIL

GIL不是python的特性，是在实现解释器CPython时引入的一种机制。python解释器有很多，其中最常用的就是CPython，所以GIL的问题就成了python的问题，当然也有些解释器是没有GIL的。
https://www.cnblogs.com/SuKiWX/p/8804974.html

* 为何会有GIL

当python在多核时代支持多线程时，为了解决多线程之间数据完整性和状态同步的问题，需要在访问内存时进行加锁。为了减少管理锁的开销，就加了个`大锁`，保证同时只有一个线程在执行，也就是同一时间只会有一个线程在CPU上执行，其它线程睡眠或者等待I/O，如果不加大锁，就需要在访问共享资源时加很多`细粒度`的锁，这样会带来一定的锁管理开销，而且现在已经有很多的库代码依赖GIL，使得已经无法将GIL拿掉了。

* GIL对程序有何影响

对于IO密集型程序，python多线程虽然不能同时执行python代码，但是可以在等待IO的过程中多个线程交替执行，比单个线程更快。
而对于计算密集型程序，python多线程并不会比单线程更快，而且由于线程切换的开销以及线程之间GIL的争抢，有可能多线程更慢，此时可以用多进程处理。

* GIL中的几种策略

(1) 当一项任务在不确定的时间段内不需要执行python代码，该线程就会让出GIL，让其它线程可以获取GIL从而运行python代码(主动释放锁)
(2) 为了保证其它线程也可能执行python代码，解释器在执行字节码时，会定期放弃GIL(被迫释放锁)
(3) 即使有GIL(GIL只能保证不会有多个线程同时访问一块内存导致出现未知的错误)，在多个线程用非原子操作去操作共享资源时，依然需要进行加锁，因为多个线程交替执行时如果操作不是原子的，也会出现逻辑上的错误(也就是说，逻辑上的正确性需要程序员用锁去保证)

### 2 线程安全

线程为何会不安全？
线程共享“资源”，如果对资源的访问不能保证原子性就不能保证执行的正确性

### 3 weakref

https://segmentfault.com/a/1190000005729873

弱引用的用处(为什么会存在弱引用)：

* 消除循环引用。python中的垃圾回收机制是根据引用计数进行回收的，当某个对象的引用计数为0时，就会进行回收操作，那么当一组对象之间存在循环引用，那么对象就不会被回收，如果存在大量这种对象，就会发生内存泄漏。
* 对象缓存。python中的提供了字典类型的弱引用，将元素放入到这样的字典时，用的就是弱引用，那么当系统资源不足时，垃圾回收机制就可以回收占用资源较多的对象，而不需要用户手工去管理字典中的数据。

关于python类中的__weakref__：

__weakref__引用了当前对象的所有弱引用，当调用weakref.ref()时就创建了一个引用，该引用既赋给了目标对象，也存储在当前对象的__weakref__。

### 4 垃圾回收

常见的垃圾回收机制：

1 标记-清除

2 引用计数

python中的垃圾回收机制：

### 4 instance method、class method、static method

``` python
class A(object):

    # instance method
    # 实例方法：需要绑定对象使用
    def i_func(self):
        print("instance method")
    
    # class method 类方法
    # 1 可以通过对象或者类进行调用
    # 2 可以实现类似C++中的重载函数功能
    @classmethod
    def c_func(cls):
        print("class method")
    
    # static method 静态方法
    # 1 可以通过对象或者类进行调用
    # 2 跟普通函数一样，但是它不关心对象和属性
    @staticmethod
    def s_func():
        print("static method")
```

### 5 deep copy

python中深拷贝和浅拷贝主要针对的是集合类型(可变类型)，例如，list、dict、set。当对集合类型进行赋值时，进行的是浅拷贝：两个引用指向的是同一块内存区域。

如果需要进行深拷贝，需要使用copy.deepcopy()，它可以`递归的`对集合类型进行深拷贝(对于list类型，l2=l1[:]虽然可以将l1中所有成员重新赋值一份到l2中，但是如果l1中还有其它的集合类型，这种方式就还是浅拷贝)。

* 赋值：复制引用，使用同一块内存；浅拷贝：copy.copy()，只会拷贝其中的非集合类型，对于集合类型，还是浅拷贝；深拷贝：copy.deepcopy，会递归对集合进行深拷贝
* 如果元组中只不可变类型，则不会进行深拷贝

### 6 lambda 短小的匿名函数

``` python
mul2 = lambda x: x * 2
```

### 7 closure 闭包

### 8 magic method

* __getattribute__

* __getattr__和__setattr__

### 9 vargant & docker


