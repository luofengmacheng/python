## 异常处理

### 1 为什么需要异常处理

任何看似简单的程序在应对复杂的使用情况时，会出现各种各样的问题，虽然防御性编程可以预先估计大量的问题，但是总会出现各种没有事先预料到的问题。

而且，防御性编程通常只能处理软件出错的问题，如果是硬件或者其它问题，防御性编程并不能派上用场。

这时候，无论是开发还是测试过程中，异常处理都可以防止让程序异常退出，并给予程序员记录错误的机会，让程序员可以从日志中知道程序崩溃时，到底发生了什么。

### 2 何时需要使用异常处理

异常处理当然是很有用的调试和问题定位工具，那么什么时候才需要使用异常处理呢？难道每个语句都需要包含在try-catch语句中吗？或者，难道一个简单的赋值语句都需要包含在try-catch语句中吗？

* 原则1：需要与外界交互的语句需要用异常处理。例如，读写文件时，可能由于文件所在的磁盘突然出现故障，导致读写文件异常；当调用外部的接口时，有可能接口返回的信息无法处理，导致处理异常。在这种情况下，我们无法预知会出现什么问题，而且出现问题后也无法处理，只能在日志中记录该问题，但是，这种情况下必须做两件事：告知使用者出现异常情况；防止程序异常退出。

* 原则2：调用其它库的函数进行处理时需要使用异常处理。例如，在调用codecs库进行文件读写时，如果遇到特殊字符，就会异常退出，文件中出现何种不可解析字符是无法预知的，但是，我们又不想程序退出，因此，只需要在无法解析出特殊字符时进行记录以备问题定位即可。

### 3 如何使用异常处理

上面的讲解中使用try-catch指代异常处理语句，而在python中，使用的是try-except：

```python
try:
    1/0
    num = 1
except Exception:
    log.error("error occured")
finally:
    '清理工作'
```

以上就是python中异常处理语句的基本结构，与其它C++/java中的结构类似。

在try和except语句之间包含可能会发生异常的部分。except子句是异常处理的语句。finally子句主要用于清理工作，如文件的关闭，资源的释放等。

如上例所示，当发生异常时，接下来的一行赋值语句不会执行，而是会直接跳转到except进行异常捕获，找到合适的异常处理器，如果没有找到，则会继续往上层抛出异常。在上例中，我们使用了可以捕获任何异常的处理器，处理的方式只是简单的打印一条日志。当处理完成后，如果有finally，会执行finally部分的语句，这部分语句是无论是否发生异常都会进行的操作。

有时候，我们可能需要打印错误信息，而不是只是知道发生了错误，这时候，需要将异常实例化：

```python
try:
    1/0
    num = 1
except Exception, err:
    log.error(err)
finally:
    '清理工作'
```

这里将异常实例化为一个异常对象，它其实就是错误信息的字符串，于是，这里就会将`integer division or modulo by zero`打印到日志中。

### 4 打印堆栈信息

通常，代码都是各个函数之间的调用，一层调用一层，当我们在最外围捕获异常时，只能知道是这部分代码有问题以及问题发生的类型，但是，由于各个函数的相互调用，无法精确地定位到发生异常的地方，这时候，就需要将异常的堆栈打印出来：

```python
import traceback

try:
    1/0
    num = 1
except Exception, err:
    log.error(traceback.format_exc())
finally:
    '清理工作'
```

### 5 总结

与C/C++等不一样，python的库函数的操作的结果有可能不会通过返回值表现出来，例如，当os.mkdir()创建目录失败时，会抛出OSError异常，而不是在返回值中返回False，这时候就不能通过判断返回值得到目录是否创建成功，而是应该对该语句进行异常捕获，从而得知该函数是否调用成功。

在开发自测过程中，异常是一把有力定位BUG的剑，通过异常返回的信息，以及堆栈信息，能够让程序员快速知道哪里发生了问题，以便快速修复。

当然，异常也不是万能的，如果程序出现了无穷递归等问题导致程序异常退出，是无法捕获该异常的。但是，这一点瑕疵并不妨碍异常成为除虫的工具。